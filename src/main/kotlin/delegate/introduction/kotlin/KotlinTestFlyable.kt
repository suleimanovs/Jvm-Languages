package delegate.introduction.kotlin

/**
 * Created by osmanboy on 1/30/2022
 */
/**
 * Паттерн делегат очень простой:один объект передает выполнение своего метода другому объекту.
 * Поддержка делегирования позволяет избавиться от множества делегирующих методов в вашем коде.
 * Например, в Kotlin это выглядит так:
 */
internal interface Flyable {
    fun flyToRight()
    fun flyToLeft()
}

internal class Plane : Flyable {
    override fun flyToRight() = println("Лечу на право!")


    override fun flyToLeft() = println("Лечу на лево!")

}

/**
 * 1. Теперь, во-первых, мы должны писать код на уровне абстракций, а не реализаций.
 * 2. Так же, что если класс, чей код мы хотим наследовать, можем быть как final(запрещен для наследования)
 * 3. Что если наш класс уже имеет родителя, то есть уже наследован от какого-то класса, то мы не можем наследоваться
 * от двух классов одновременно.
 * В таких случаях на помощь приходит паттерн Делегирование.
 * То же самое, но в Java: [delegate.introduction.java.JavaTestFlyable]
 */
internal class Bird(private val flyable: Flyable) : Flyable by flyable {

    /**
     * Нет, я не забыл реализовать метод [flyToRight] у [Bird], он там реализован. Он использует реализацию из [flyable]
     * Разве не видно? Вот в этой строчке: Flyable by flyable.
     * Эта языковая конструкция с использованием ключевого слова by говорит, что реализацию методов интерфейса Flyable
     * нужно делегировать полю flyable. При этом декомпилированный в Java код выглядит так же
     * как и пример на Java: [delegate.introduction.java.JavaTestFlyable].
     */

    /**
     * Теперь, если вам понадобится изменить поведение некоторых методов, вы сможете переопределить их и
     * вместо сгенерированных методов вызывать ваш код. Вы можете пропустить методы, реализация которых
     * по умолчанию устраивает вас, делегируя выполнение декорируемому экземпляру.
     */
    override fun flyToLeft() = println("Лечу на лево опускаясь ниже!")

}

fun main() {
    val flyable: Flyable = Plane() //конкретная реализация интерфейса Flyable
    val bird = Bird(flyable) //передаем объект типа Flyable
    bird.flyToLeft() //наша собственная реализация.
    bird.flyToRight() // реализация из класса Plane
}


/**
 * Что в этом плохого? Ведь теперь тривиальные реализации интерфейсов можно будет не писать.
 * Вот, какой минус вижу я:
 *    -Теряется контроль за зоной ответственности объекта, так как непосредственные реализации будут скрыты от
 *     взгляда программиста. На ревью сложно оценить количество методов у класса, который использует Class Delegation
 *
 *
 * Допустим, вы читаете чужой код, видите там строчку:
 *    -bird.flyToRight()
 * И, вам надо узнать, что происходит в методе [flyToRight].
 * Вы знаете, что этот метод вызывается у объекта класса [Bird],
 * поэтому вы открываете код этого класса и … там нет метода [flyToRight].
 * П - паника. Конечно, через пару часов вы увидите, что там Class Delegation,и метод просто скрыт.
 * И вы потеряете больше времени на понимание происходящего, чем если бы там был делегат здорового человека.
 * Делегат здорового человека - курильщика
 *
 * Используя делегаты в Kotlin вы обрекаете себя на более высокую стоимость разработки.
 */
