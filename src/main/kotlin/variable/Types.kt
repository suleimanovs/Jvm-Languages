package variable


fun main() {

    /**
     * Kotlin предоставляет только один вид типов: ссылочные типы, примитивов нет.
     * Примитивы обеспечивают лучшую производительность, чем ссылочные типы! Но в байткоде мы найдем такое :
     * public final int twenty = 12;
     * Как видите, вместо ссылочного использован простой тип. Как такое возможно, если Kotlin поддерживает только
     * ссылочные типы? Компилятор Kotlin, если есть такая возможность, использует примитивы байт-кода Java, потому что
     * они действительно обеспечивают лучшую производительность. Kotlin предоставляет удобство ссылочных типов
     * и производительность примитивов. В Kotlin вы найдете соответствующие ссылочные типы для восьми примитивов,
     * с которыми вы, возможно, уже знакомы по Java.
     */

    val s: String = "String"
    val twenty: Int = 12
    val someDouble: Double = 0.4255
    val someFloat: Float = 0.244242F
    val someLong: Long = 3535246464262L
    val someShort: Short = 13131
    val someByte: Byte = 127
    val someChar: Char = 's'
    val someBoolean: Boolean = false
    /**
     * Как следствие, меньшие типы НЕ преобразуются неявно в более крупные. Это означает, что для присвоения
     * значения type переменному требуется явное преобразование:ByteInt
     */
    val b: Byte = 1 // OK, literals are checked statically
// val i: Int = b // ERROR
    val i1: Int = b.toInt()


    /**
     * Во многих случаях нет необходимости в явных преобразованиях, поскольку тип выводится из контекста
     */
    val l = 1L + 3 // Long + Int => Long

}

