package generic

/**
 * определение вариантности в месте использования в языке Kotlin прямо соответствует ограниченным мета символам в Java.
 * Объявление MutableList<out Т> в Kotlin означает то же самое, что MutableList<? extends Т> в Java,
 * а входящая проекция MutableList<in Т> соответствует MutableList<? super Т>.
 */

/**
 * Такой подход является инвариантным
 */
fun variance(list: MutableList<Number>) {
    println(list.joinToString())
}

/**
 * Такой подход является Ковариантный(направление отношения тип - подтип сохраняется)
 * Объявление класса ковариантным по определенному типовому параметру ограничивает возможные способы
 * использования этого параметра в классе.
 * Чтобы гарантировать безопасность типов, он может использоваться только в так называемых исходящих (оиt) позициях:
 * то есть класс может производить значения типа т, но не потреблять их.
 *
 *
 * Ключевое слово out в параметре типа класса требует, чтобы все методы, использующие т,
 * указывали его только в исходящей позиции.
 * Это ключевое слово ограничивает возможные варианты использования т, чтобы гарантировать безопасность соответствующего
 * отношения с подтипом.
 *
 */
fun covariance(list: MutableList<out Number>) {
    println(list.joinToString())
}


/**
 *  Контравариантность: направление отношения тип - подтип изменяется на противопопожное
 *  Понятие контравариантности можно рассматривать как обратное понятию ковариантности: для контравариантного класса
 *  отношение тип-подтип действует в противоположном направлении относительно отношения между классами, использованными
 *  как типовые аргументы
 */
fun counterVariance(list: MutableList<in Number>) {
    println(list.joinToString())
}

fun main() {

    variance(mutableListOf<Number>())
//  variance(mutableListOf<Int>())


    covariance(mutableListOf<Number>())
    covariance(mutableListOf<Int>())


    counterVariance(mutableListOf<Number>())
    counterVariance(mutableListOf<Any>())


}