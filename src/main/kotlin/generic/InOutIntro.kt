package generic

class User<P> {

    companion object {
        /**
         * При таком объявления метода оба параметров должны быть списком одного и того же типа.
         * Если мы параметризовали функцию как User<Number>, то передать сможем только User<Number>, User наследников Number
         * передать не выйдет.
         */
        fun <T> transfer(src: User<T>, dst: User<T>) = Unit
    }
}

/**
 * Out - ковариантность. Используется только в выходных позициях. А так же для переменных val типа, так как для val
 * генерируется только getter.
 * Если использовать во входящих позициях, как тип параметра функций, или для var свойств(у них генерируется setter),
 * то компилятор выдаст ошибку, но это правила не касается конструкторов.
 *
 * Даже если параметр типа объявить как out, вы все ещё сможете использовать его в объявлениях параметров конструктора.
 * Вариантность защищает от ошибок, когда экземпляры класса используются как экземпляры более обобщенного типа:
 * вы просто не сможете вызвать потенциально опасных методов.
 * Конструктор - это не метод, который можно вызвать позднее (после создания экземпляра),
 * поэтому он u не представляет потенциальной опасности
 *
 * Однако если параметры конструктора объявлены с помощью ключевого слово var,
 * то вместе с ними объявляется метод записи.
 * Поэтому параметр типа оказывается в исходящей позиции для изменяемых свойств.
 *
 * Отметьте, что правила позиции охватывают только видимое извне (public, protected и internal) API класса.
 * Параметры приватных методов не находятся ни в исходящей, ни во входящей позициях.
 * Правила вариантности защищают класс от неправильного использования внешними клиентами и не применяются
 * к внутренней реализации класса:
 */
class Student<out P>(val profession: P, private var s: P = profession) {

    val someThing: P = profession
//  var profession2: P = profession так объявить не выйдет

    fun get(): P {
        return profession
    }

    companion object {
        /**
         * Если мы параметризовали функцию как Student<Number>, то сможем передать Student<Number> и любых наследников Number,
         * вроде Student<Int>, Student<Float>
         */
        fun <T> transfer(student: Student<T>) = Unit

    }


}


/**
 * In - контравариантность. Используется только на входных позициях. Запрещается использовать в качестве возвращаемого
 * типа для функций. Запрещает присвоить переменным типа var/val. Так как для обеих генерируется getter, который в свою
 * очередь возвращает значение в качестве возвращаемого типа
 *
 * Ключевое слово in означает, что значения соответствующего типа передаются в методы данного
 * класса (считаются входящими значениями) и потребляются этими методами. Подобно случаю ковариантности,
 * ограничение на использование типового параметра делает возможным конкретное отношение тип-подтип.
 * Ключевое слово in перед именем типового параметра т сообщает, что направление отношения тип-подтип меняется
 * на противоположное и т может использоваться только во входящих позициях.
 *
 */
class Killer<in P> {

//  var profession1: P error
//  val profession2: P error

    fun put(value: P) {
        println(value)
    }

    companion object {
        /**
         * Если мы параметризовали функцию как Student<Int>, то сможем передать Student<Int> и любого родителя Int,
         * вроде Student<Number>, Student<Any>
         */
        fun <T> transfer(student: Killer<T>) = Unit

    }
}


fun main() {

    User.transfer<String>(User<String>(), User<String>())
    /**
     * Хоть класс [String] является наследником [CharSequence], но List<String> не является наследником List<CharSequence>
     * Следующий код выбросит compile error
     */
//  transfer<CharSequence>(mutableListOf<String>("str", "str2"), mutableListOf<CharSequence>())

    /**
     * И теперь в метод параметризованный типом [Number], мы можем передать User параметризованный любым
     * типом производный от [Number], например [Double],[Long]
     */
    Student.transfer<Number>(Student<Int>(11))
    Student.transfer<Number>(Student<Float>(34f))

    /**
     * Случай когда мы хотим что бы можно было бы передать супертипы
     */

    Killer.transfer<Int>(Killer<Int>())
    Killer.transfer<Int>(Killer<Number>())
    Killer.transfer<Int>(Killer<Any>())
}

