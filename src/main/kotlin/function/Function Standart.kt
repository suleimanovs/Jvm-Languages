package function

import java.io.File
import kotlin.random.Random

 /**
  * Объект получатель(экземпляр типа)(this) - тип или объект  для которого была вызвана функция,
  * например (Int, List, Any, String,Context) и т.д
  * Результат лямбды выражения, это то что лямбда в итоге возвращает
  */

fun main() {


    val name: String? = "Osman"
     val random = Random.nextInt()

     /**
     * apply - она позволяет вызвать несколько функций для объекта-получателя, после выполнения
     * указанного лямбда выражения apply возвращает настроенный объект-получатель,
     * для обращения к содержимому используется this, но его можно опустить.
     *
     * apply позволяет отбросить имя переменной в каждом вызове функции, выполняемом для настройки объекта-получателя,
     * потому что все функции в лямбде вызываются относительно объекта-приемника, для которого вызвана сама функция.
     */

    val file = File("D:\\ic_eva_logo.xml").apply {
        setReadable(true) // На самом деле, file.setReadable(true)
        setWritable(true)
        setExecutable(false)
    }


    /**
     * let определяет переменную в область видимости заданной лямбды и позволяет использовать ключевое слово it
     * let - обычно используется для того что бы избавиться от nullable по умолчанию она создает
     * переменную it для обращения [и он возвращает -Результат лямбды выражения]
     */
    name?.let {
        if (it.length > 5) {
            println(it)
        }
    }

     /**
      * let - принимает лямбду, и передает объект приемник в лямбду, лямбда возвращает измененный
      * тип, а сама функция возвращает результат лямбды
      */
     val let = random.let {
         it.toString()
     }


    /**
     * with - была придумана для случаев, когда нам нужно произвести множество операций с одним и
     * тем же обьектом, в качестве параметра она принимает любой обьект, а для обращения
     * используется this, но его можно и опустить
     * [и он возвращает -Результат лямбды выражения ] - рекомендуется использовать run вместо with
     */
    with(name) {
        this?.length
        this?.split(",")
        this?.get(2) //лямбда вернет элемент по индексу

    }


    /**
     * run - похожа на apply, но в отличий от него run возвращает результат лямбды -  в нашем
     * случае boolean run так же принимает ссылку на функцию
     */

    val menuFile = File("D:\\ic_eva_logo.xml").run {
        this.readText().contains("some")
    }


    /**
     * also - похожа на let? , он передает объект применик в лямбду,  но возвращает обЪект
     * приемник, а не результат лямбды
     */
    File("D:\\ic_eva_logo.xml").also {
        println(it.name)
    }.also {
        val array = it.readLines()
    }


    /**
     * takeIf - вычисляет условие или predicate(функцию) заданное в лямбде которая возвращает
     * boolean, если true то результат, то вернёт объект приемник, а если лож то null
     */
    val array = arrayOf(1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10)
    array.takeIf { it.size > 10 }


    //OTHER EXAMPLE



    /**
     * Also - принимает лямбду, и передает объект приемник в лямбду(сама лямбда нечего не
     * возвращает), а функция возвращает сам объект приемник.
     */
    val also = random.also {
        it.toString()
    }


    /**
     * apply-принимает лямбду-рассширение, лямбда вызваеться для объекта приемника(но сама нечего
     * не возвращает), а функция возвраащет сам объект приемник
     */
    val apply = random.apply {

    }





    /**
     * Run - принимает лямбду-расширение, лямбда вызывается для объекта приемника,
     * лямбда возвращает измененный тип, а сама функция возвращает результат лямбды
     */
    val run = random.run {

    }

    run{

    }


    /**
     * with - принимает объект приемник, а так же лямбду, которая расширяет объект приемник, и возвращает результат лямбды
     */
    val with = with(random) {

    }

}
