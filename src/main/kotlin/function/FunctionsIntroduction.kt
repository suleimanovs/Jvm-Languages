package function


/**
 * Методы чьи тел содержат только одно выражение можно сократит так
 *  Если в методе всего лишь одно действие, то можно опустить фигурные скобки
 */
fun getFirstChar(s: String) = s.first()


/**
 * Методы c дефолтным значением параметров и с возвращаемым типом Unit(void)
 */
fun printName(name: String = "Osman") {

    /**
     * Именованные аргументы функций. Именованные аргументы можно передавать в функцию в любом порядке.
     * Без использования именованных аргументов их можно передавать только в том порядке, в каком они указаны в
     * заголовке функции.
     * Именованные аргументы можно передавать в любом порядке, независимо от их порядка в заголовке функции.
     */
    println(getFirstChar(s = name))
}

/**
 * Все функции, которые мы писали выше, объявлялись на уровне файла Game.kt.
 * Если вы — разработчик Java, это может вас удивить. В Java функции и переменные могут быть объявлены только внутри
 * классов. Это правило не относится к Kotlin.
 * Возможно ли такое, чтобы код языка Kotlin компилировался в байт-код Java для запуска на JVM?
 * Разве Kotlin не должен придерживаться тех же правил?
 * Если посмотреть на скомпилированный байт-код Java для FunctionsIntroduction.kt, то все станет ясно:
 *
 * public final class FunctionsKt {
 *
 *      public static final char getFirstChar(@NotNull String s) {
 *              ....
 *      }
 *
 *       public static final void printName(@NotNull String name) {
 *              ....
 *      }
 * }
 * Функции уровня файла представлены в Java как статические методы класса с именем, совпадающим с именем файла в Kotlin.
 * (Методы в Java — это то же самое, что и функции.) В этом случае функции и переменные, объявленные
 * в FunctionsIntroduction.kt, объявляются в Java в классе с именем FunctionKt
 */


/***
 * Во-первых, эта функция нужна, чтобы поддерживать совместимость с Java.
 * Kotlin поддерживает возможность вызова методов Java из существующего кода в файле Kotlin.
 * Так как Kotlin и Java имеют разные зарезервированные ключевые слова, то есть слова, которые
 * нельзя применять в качестве имен для функций, имена функций в обратных
 * кавычках позволяют избежать несовместимости в случаях, если это необходимо.
 *
 * Вторая причина — поддержка более выразительных имен функций, которые можно использовать, например, в тестах.
 */
fun `when 10 devide by 5 must be 2`() {
}



