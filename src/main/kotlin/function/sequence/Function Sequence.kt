package function.sequence


data class Person(val name: String, val age: Int)

fun main() {


    val persons = listOf(
        Person("Alisa", 20),
        Person("Bob", 40),
        Person("Shadow", 18),
        Person("Osman", 21),
        Person("Ivan", 28),
        Person("Oleg", 22),
        Person("Michael", 44),
        Person("Lincoln", 38),
        Person("Ramo", 32),
        Person("Marsel", 56),
    )


    /**
     * Эти функции немедленно создают промежуточные коллекции, т. е. результат, полученные на каждом промежуточном шаге,
     * сразу же сохраняется во временном списке. Это значит, что данная цепочка вызовов создаст два списка:
     * один - для хранения результатов функции filter и другой - для результатов функции map.
     * Это не проблема, если в исходном списке всего пара элементов, но в случае со списком из миллиона элементов это может
     * существенно снизить эффективность операции.
     *
     * Сначала произойдет итерация для каждого элемента, и вызовется [filter] создастся промежуточная коллекция.
     * Затем произойдет итерация для каждого элемента, и вызовется [map] создастся еще промежуточная коллекция.
     * При этом, каждый метод выполнится немедленно друг за другом, а не лениво. То есть каждый метод уже является
     * терминальным(возвращает результат)
     */
    val personsWhoAgeMoreThen301 = persons
        .filter {
            println("collection filter for:$it")
            it.age > 30
        } // filter вызывается для всех элементов, при завершениях возвращает коллекцию и передает управление map
        .map {
            println("collection map for:$it")
            it.name
        } // map вызывается для всех элементов, и только при завершениях возвращает коллекцию

    // println(personsWhoAgeMoreThen301)

    /**
     * [Sequence] это некий аналог [java.util.stream.Stream], где есть понятие промежуточные и терминальные операторы,
     * промежуточные операторы запускаются только при вызове терминального. Все операторы объединяются в один,
     * и вызываются для каждого элемента только один раз, и все только за одну итерацию.
     * Для повышения эффективности нужно реализовать операцию с применением последовательностей вместо коллекций:
     * Последовательности (sequences) дают альтернативный способ реализации таких вычислений, позволяющий избежать создания
     * временных промежуточных объектов.
     *
     * Операции над последовательностями делятся на две категории: промежуточные и завершающие.
     * Промежуточная операция возвращает другую последовательность, которая знает, как преобразовать элементы исходной
     * последовательности. Завершающая операция возвращает результат, который может быть коллекцией, элементом,
     * числом или любым другим объектом, полученным в ходе преобразований исходной коллекции
     * Завершающая операция заставляет выполниться все отложенные вычисления.
     *
     * Эта операция вернет тот же результат, что и предыдущий пример: список имен, старше 30
     * Этот пример не создает промежуточных коллекций для хранения элементов, а следовательно, для большого
     * количества элементов производительность будет заметно лучше
     *
     * Еще одна важная деталь, которую нужно отметить в этом примере,- порядок выполнения вычислений.
     * При реализации <<В лоб>> к каждому элементу сначала применяется функция map, а затем вызывается функция filter
     * для каждого элемента получившейся последовательности. Так функции map и filter работают с коллекциями,
     * но не с последовательностями.
     *
     * Для последовательности все операции применяются к каждому элементу поочередно: сначала обрабатывается первый
     * элемент (преобразуется, а затем фильтруется), затем второй и т. д.
     * Такой подход означает, что некоторые элементы могут вовсе не подвергнуться преобразованию,
     * если результат будет вычислен прежде, чем до них дойдет очередь. Давайте посмотрим пример с операциями find и map.
     */

    val personsWhoAgeMoreThen302 = persons.asSequence()
        .filter {
            /**
             * [filter] - вызовется для одного элемента, после вернет управление map, если элемент удовлетворил требования
             * [filter], если нет, то вызовется для следующего элемента в последовательности.
             * После того как последний промежуточный оператор(в нашем случае это [map] сделает свое вычисление,
             * он снова вернет управление [filter], то есть первому оператору в Sequence
             */
            println("sequence filter for:$it")
            it.age > 30
        }.map {
            println("sequence map for:$it")
            it.name
        }.toList()// без терминального оператор промежуточные не начнут свое выполнение


    /**
     * [Sequence] и [java.util.stream.Stream] Знакомые с потоками (streams) в Java 8 без труда узнают их в последовательностях.
     * Kotlin предлагает собственную версию этой идеи, потому что потоки Java 8 недоступны на платформах,
     * основанных на старых версиях Java (таких, как Android).
     * Если вы ориентируетесь на Java 8, потоки дадут вам одно большое преимущество, которое в настоящее время
     * не реализовано для коллекций и последовательностей в Kotlin,- возможность
     * запуска потоковой операции (напримерt map или filter) параллельно на нескольких процессорах.
     * Вы можете выбирать между потоками и последовательностями в зависимости от версии Java и ваших особых требований.
     */

}